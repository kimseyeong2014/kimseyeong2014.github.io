<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAM1BMVEVHcEz/AAD/AAD/BQD/GwD/MQD/9QDd/yOy/03/4ACT/2xo/5f/wgAz/80B////kQD/XQB4LdJ7AAAABnRSTlMAF1uNwPOmyTibAAAAqUlEQVR42r2TSw4EIQhER21AerTh/qcdMcaYdhJ2vm1VKOXzOUxMVyPF/2pIoCoNVUhh1yOoFMYGF1HYqqQmIw2wWdKmM1HOdyNnIn45ogqa/O2YBUWXlADCZHLtmIVYICwBxfRan06t5ihLCFhA16fDQmC+YBR4JqNEnAlMuesTK8Ez4xKk+224CeU6YHAf6X7Ta5Tfan9Y/rj9hfFXzl9af+33wzl8rz+5QxYpNbP30QAAAABJRU5ErkJggg==">
    <title>풍선 터트리기</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100dvh;
            background-color: #f0f0f0;
            touch-action: manipulation;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            background-color: white;
            cursor: crosshair;
        }

        .kakao-ad {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 160px;
            height: 600px;
            z-index: 10;
        }
        #kakao-ad-left {
            left: 10px;
        }
        #kakao-ad-right {
            right: 10px;
        }

        @media (max-width: 1200px) {
            .kakao-ad {
                display: none;
            }
        }

        #ui-overlay {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            width: 800px;
            height: 600px;
        }
        #ui-overlay > * {
            pointer-events: auto;
        }
        h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            color: #333;
        }
        #ui-overlay.only-input.rank-input > :not(#nameInputBox) {
            display: none !important;
        }

        button {
            padding: 15px 40px;
            font-size: 24px;
            font-family: 'Arial', sans-serif;
            cursor: pointer;
            background-color: #ff4757;
            color: white;
            border: none;
            border-radius: 30px;
            transition: transform 0.2s, background-color 0.2s;
            margin-top: 10px;
        }
        button:hover {
            transform: scale(1.1);
            background-color: #ff6b81;
        }

        #homeBtn, #downloadBtn, #rankBtn, #submitRankBtn, #googleBtn, #nameBtn, #shopBtn {
            background-color: #2f3542;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 20px;
            width: 120px;
        }
        #showResultBtn {
            padding: 12px 32px;
            font-size: 20px;
            border-radius: 24px;
        }
        #submitRankBtn {
            background-color: #ffd43b;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 350px;
            z-index: 50;
        }
        #submitRankBtn:hover {
            background-color: #ffe066;
        }

        .result-button-container {
            position: absolute;
            top: 10px;
            right: 40px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        #downloadBtn {
            background-color: #2ed573;
            pointer-events: auto;
        }
        #downloadBtn:hover {
            background-color: #7bed9f;
        }

        .button-group {
            margin-top: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .hidden {
            display: none !important;
        }

        #tipText {
            position: absolute;
            bottom: 30px;
            font-size: 20px;
            pointer-events: none;
        }

        #googleBtn, #nameBtn, #shopBtn {
            position: absolute;
            top: 10px;
        }
        #googleBtn {
            left: 40px;
            background: #1e90ff;
        }
        #googleBtn.logout {
            background: #ff4757;
        }
        #nameBtn {
            left: 170px;
            background: #2f3542;
        }
        #shopBtn {
            width: 80px;
            background: #8e44ad;
        }

        #nameInputBox.rank-mode {
            margin-top: 340px;
        }
        #nameInputBox.rename-mode {
            position: absolute;
            top: 70px;
            left: -340px;
            right: 0;
        }

        #adModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
            opacity: 0;
            pointer-events: none;
        }

        #adModal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .ad-box {
            position: relative;
            background: white;
            padding: 40px;
            border-radius: 16px;
        }

        #closeAdBtn {
            position: absolute;
            top: -6px;
            right: 4px;
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 50%;
            border: none;
            background: #ff4757;
            color: white;
            line-height: 36px;
            font-size: 20px;
            cursor: pointer;
        }

        #closeAdBtn:disabled {
            background: #aaa;
            cursor: not-allowed;
        }

        #nameOkBtn {
            padding: 6px 12px;
            font-size: 24px;
            border-radius: 12px;
            margin-top: 0;
            background: #ff4757;
        }

        #ui-overlay.only-shop > :not(#shopModal) {
            display: none !important;
        }
        #shopModal {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }
        .shop-box {
            width: 720px;
            height: 520px;
            background: white;
            border-radius: 18px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 18px;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .shop-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 10px;
        }
        .shop-title {
            font-size: 34px;
            font-weight: 700;
        }
        .shop-coins {
            font-size: 22px;
            font-weight: 700;
        }
        .shop-close {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            padding: 0;
            font-size: 22px;
            background: #ff4757;
        }
        .shop-tabs {
            display: flex;
            gap: 10px;
            margin: 8px 0 14px 0;
        }
        .shop-tab {
            flex: 1;
            padding: 10px 0;
            font-size: 20px;
            border-radius: 14px;
            background: #dfe4ea;
            color: #2f3542;
        }
        .shop-tab.active {
            background: #2f3542;
            color: white;
        }
        .shop-content {
            flex: 1;
            overflow: auto;
            padding: 8px;
            border-radius: 14px;
            background: #f6f7fb;
        }
        .shop-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: white;
            border-radius: 14px;
            padding: 12px 12px;
            margin-bottom: 10px;
        }
        .shop-row .left {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 700;
        }
        .shop-badge {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 10px;
            border-radius: 999px;
            background: #ecf0f1;
        }
        .shop-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .shop-mini {
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 12px;
            width: auto;
            background: #2f3542;
        }
        .shop-mini.buy {
            background: #2ed573;
        }
        .shop-mini.buy:disabled {
            background: #aaa;
            cursor: not-allowed;
        }
        .shop-mini.use {
            background: #ffd43b;
            color: black;
        }
        .shop-mini.using {
            background: #57606f;
        }
    </style>
</head>
<body>

<div id="ui-overlay">
    <button id="googleBtn">구글 로그인</button>
    <button id="shopBtn">상점</button>
    <button id="nameBtn" class="hidden">이름 바꾸기</button>
    <h1 id="gameTitle">풍선 터트리기</h1>
    <button id="startBtn">게임 시작</button>
    <div id="tipText">TIP:</div>
    <div class="result-button-container">
        <button id="homeBtn" class="hidden">처음으로</button> 
        <button id="downloadBtn" class="hidden">결과 받기</button>
    </div>
    <div id="endButtons" class="button-group hidden">
        <button id="showResultBtn">결과 보기</button>
    </div>
    <div id="nameInputBox" class="hidden" style="text-align:center;">
        <div id="nameError" style="color:red;font-size:16px;margin-bottom:6px;"></div>
        <div style="display:flex;gap:8px;justify-content:center;align-items:center;">
            <span id="nameInputLabel" style="font-size:22px;">이름:</span>
            <input id="nameInput" maxlength="10" style="width:222px;font-size:24px;">
            <button id="nameOkBtn">O</button>
        </div>
    </div>
    <div id="shopModal" class="hidden">
        <div class="shop-box">
            <div class="shop-top">
                <div class="shop-title">상점</div>
                <div class="shop-coins"><span id="shopCoins">0</span> ⓒ</div>
                <button id="shopCloseBtn" class="shop-close">✕</button>
            </div>

            <div class="shop-tabs">
                <button class="shop-tab active" data-tab="name">이름</button>
                <button class="shop-tab" data-tab="icon">아이콘</button>
                <button class="shop-tab" data-tab="item">아이템</button>
            </div>

            <div id="shopContent" class="shop-content"></div>
        </div>
    </div>
    <button id="rankBtn">순위 보기</button>
</div>
<button id="submitRankBtn" class="hidden">순위에 들기</button>
<canvas id="gameCanvas" width="800" height="600"></canvas>

<div id="kakao-ad-left" class="kakao-ad">
  <ins class="kakao_ad_area"
    data-ad-unit="DAN-Xy8lp7VZ6H3qs38x"
    data-ad-width="160"
    data-ad-height="600"></ins>
</div>

<div id="kakao-ad-right" class="kakao-ad">
  <ins class="kakao_ad_area"
    data-ad-unit="DAN-vmvUv4rYl1k1NSGQ"
    data-ad-width="160"
    data-ad-height="600"></ins>
</div>

<div id="adModal">
  <div class="ad-box">
    <button id="closeAdBtn">✕</button>
    <ins class="kakao_ad_area"
      data-ad-unit="DAN-GXBiKh9QhvltLgkB"
      data-ad-width="300"
      data-ad-height="250"></ins>
  </div>
</div>
<script src="//t1.daumcdn.net/kas/static/ba.min.js" async></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
    import {
        getFirestore, collection, addDoc,
        query, where, orderBy, limit, getDocs, deleteDoc,
        doc, getDoc, setDoc, updateDoc, increment
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";
    import {
        getAuth, GoogleAuthProvider,
        signInWithPopup, signOut,
        onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-auth.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBjToZlCWZ-m0QI1YS_6qkworo4XAjmZwA",
        authDomain: "balloon--pop.firebaseapp.com",
        projectId: "balloon--pop",
        storageBucket: "balloon--pop.firebasestorage.app",
        messagingSenderId: "94138266236",
        appId: "1:94138266236:web:9de24c4c440b114d7ccff9"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const provider = new GoogleAuthProvider();
    let user = null;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const showResultBtn = document.getElementById('showResultBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const homeBtn = document.getElementById('homeBtn');
    const endButtons = document.getElementById('endButtons');
    const gameTitle = document.getElementById('gameTitle');
    const rankBtn = document.getElementById('rankBtn');
    const submitRankBtn = document.getElementById('submitRankBtn');
    const nameInputBox = document.getElementById('nameInputBox');
    const nameInput = document.getElementById('nameInput');
    const nameError = document.getElementById('nameError');
    const nameOkBtn = document.getElementById('nameOkBtn');
    const googleBtn = document.getElementById('googleBtn');
    const nameBtn = document.getElementById('nameBtn');
    const shopBtn = document.getElementById('shopBtn');
    const shopModal = document.getElementById("shopModal");
    const shopContent = document.getElementById("shopContent");
    const shopCoinsEl = document.getElementById("shopCoins");
    const shopCloseBtn = document.getElementById("shopCloseBtn");
    const MAINT = 0;
    const tips = [
      "×2는 늘 좋아요",
      "÷2는 늘 나빠요",
      "?는 -2, +1, +2, +3의 하나에요",
      "막 누르기보다 잘 눌러봐요",
      "-2는 덫이에요",
      "갈수록 빨리 나와요",
      "큰 점수는 ×2에서 와요",
      "처음은 느리니 뒤를 노려요",
      "랜덤 풍선은 기대돼요",
      "차분해야 점수가 높아요"
    ];
    tips.push(`팁은 ${tips.length+1}개 있어요`);
    const BAD = new RegExp([ "느으*[^가-힣]*금마?", "니[^가-힣]*(엄|앰|엠)", "(ㅄ|ㅅㅂ|ㅂㅅ)", "미친(년|놈)?", "(병|븅|빙)[^가-힣]*신", "보[^가-힣]*지", "(샤|쌰)[^가-힣]*갈", "(새|섀|쌔|썌)[^가-힣]*(기|끼)", "(섹|쎅)[^가-힣]*스", "(시|씨|쉬|쒸)이*입?[^가-힣]*(발|빨|벌|뻘|팔|펄)", "십[^가-힣]*새", "씹", "(애|에)[^가-힣]*(미|비)", "자[^가-힣]*지", "존[^가-힣]*나", "좆", "지랄", "창[^가-힣]*(녀|년|놈)", "bitch", "fuck", "sex" ].join('|'), "i");

    const popSound = new Audio('https://assets.scratch.mit.edu/83a9787d4cb6f3b7632b4ddfebf74367.wav');
    const tickSound = new Audio('https://playentry.org/uploads/71/ef/71efd3bcf64d5f497468c504782f050b.mp3');
    const readySound = new Audio('https://playentry.org/uploads/86/90/869085e89addb473a0799c70de94d280.mp3');
    const startSound = new Audio('https://playentry.org/uploads/43/4c/434cc2c4ac17bbce41b7fba12ee50d7b.mp3');
    const shopTabSound = new Audio('https://playentry.org/uploads/eu/yo/euyotk0hlluppgcn0uo37ec0496mk1c3.mp3');
    const shopUseSound = new Audio('https://playentry.org/uploads/2q/hu/2qhu3luulluppgd811th7ec049b18jkm.mp3');
    const shopBuySound = new Audio('https://playentry.org/uploads/d9/qs/d9qsicjslluppgdt0uo37ec0497bvkkw.mp3');
 
    const qrImage = new Image();
    qrImage.crossOrigin = "anonymous";
    qrImage.src = "https://api.qrserver.com/v1/create-qr-code/?size=100x100&data=http://풍선터트리기.kro.kr";

    const maintImage = new Image();
    maintImage.src = "https://i.ibb.co/p6RZjWJS/image.png";

    let score = 0;
    let startTime = 0;
    let balloons = [];
    let floatingTexts = [];
    let lastSpawnTime = 0;
    let isGameRunning = false;
    let isCountingDown = false;
    let isStarting = false;
    let isShowingResult = false;
    let userName = "";
    let profile = null;
    let coinsCredited = false;
    let countdownValue = 0;
    let startCountdownValue = 3;
    let rankingCache = null;
    let rankingLoading = false;
    let isShowingRanking = false;
    let hasSubmittedRank = false;
    let tipTimer = null;
    let nameInputMode = null;
    let myBestThisWeek = -Infinity;
    let myScoreDocsThisWeek = [];
    let spawnMult = 1;
    let usedItemThisRound = null;
    let maintOk = false;
    let maintSeq = "";
    const BASE_GAME_DURATION = MAINT ? 1000 : 60000;
    let gameDuration = BASE_GAME_DURATION;
    const GUEST_ICON_URL = "https://upload.wikimedia.org/wikipedia/commons/d/d7/VK_icons_user_square_outline_56.svg";
    const GOOGLE_ICON_URL = "https://upload.wikimedia.org/wikipedia/commons/c/c1/Google_%22G%22_logo.svg";
    const BALLOON_ICON_URL = "https://kimseyeong2014.github.io/무지개 풍선.svg";
    const DEVELOPER_ICON_URL = "https://upload.wikimedia.org/wikipedia/commons/3/3a/GDevs.svg";

    const SHOP = {
        nameColors: [
            { id: "black", label: "검은색 이름", price: 0, color: "black" },
            { id: "red", label: "빨간색 이름", price: 100000000, color: "red" },
            { id: "orange", label: "주황색 이름", price: 100000000, color: "orange" },
            { id: "yellow", label: "노란색 이름", price: 100000000, color: "gold" },
            { id: "green", label: "초록색 이름", price: 100000000, color: "green" },
            { id: "blue", label: "파란색 이름", price: 100000000, color: "deepskyblue" },
            { id: "indigo", label: "남색 이름", price: 100000000, color: "blue" },
            { id: "purple", label: "보라색 이름", price: 100000000, color: "purple" },
        ],
        icons: [
            { id: "general", label: "일반 아이콘", price: 0, url: GUEST_ICON_URL },
            { id: "balloon", label: "풍선 터트리기 아이콘", price: 0, url: BALLOON_ICON_URL },
            { id: "google", label: "구글 아이콘", price: 0, url: GOOGLE_ICON_URL },
            { id: "developer", label: "관리자 아이콘", price: 0, url: DEVELOPER_ICON_URL }
        ],
        items: [
            { id: "spawn1.2", label: "풍선 수 1.2배", price: 100000000, type: "spawn", mult: 1.2 },
            { id: "time10",  label: "10초 늘리기", price: 100000000, type: "time", addMs: 10000 },
        ]
    };

    function fmtCoins(n) {
        n = Number.isFinite(n) ? n : 0;
        return n.toLocaleString("ko-KR");
    }

    const BALLOON_CONF = {
        "+1": { effect: 1, color: "red" },
        "+2": { effect: 2, color: "cyan" },
        "+3": { effect: 3, color: "yellow" },
        "-2": { effect: -2, color: "lime" },
        "×2": { effect: "double", color: "rainbow" },
        "÷2": { effect: "half", color: "black" },
        "?": { effect: "random", color: "fuchsia" }
    };

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 40;
        }
        draw() {
            ctx.globalAlpha = this.life / 40;
            ctx.fillStyle = this.color;
            ctx.font = "bold 30px Arial";
            ctx.fillText(this.text, this.x, this.y);
            this.y -= 1;
            this.life--;
            ctx.globalAlpha = 1.0;
        }
    }

    class Balloon {
        constructor(duration) {
            this.radius = 40;
            this.x = Math.random() * (canvas.width - 100) + 50;
            this.y = Math.random() * (canvas.height - 150) + 100;
            const keys = Object.keys(BALLOON_CONF);
            this.label = keys[Math.floor(Math.random() * keys.length)];
            this.conf = BALLOON_CONF[this.label];
            this.spawnTime = Date.now();
            this.duration = duration;
            this.alpha = 0;
        }
        draw(now) {
            const elapsed = now - this.spawnTime;
            const remain = this.duration - elapsed;
            const fadeRange = 400;
            if (elapsed < fadeRange) this.alpha = elapsed / fadeRange;
            else if (remain < fadeRange) this.alpha = remain / fadeRange;
            else this.alpha = 1.0;
            this.alpha = Math.max(0, Math.min(1, this.alpha));
            ctx.globalAlpha = this.alpha;
            if (this.conf.color === "rainbow") {
                const gradient = ctx.createRadialGradient(this.x, this.y, 5, this.x, this.y, this.radius);
                gradient.addColorStop(1, "red");
                gradient.addColorStop(0.7, "yellow");
                gradient.addColorStop(0.1, "cyan");
                ctx.fillStyle = gradient;
            } else { ctx.fillStyle = this.conf.color; }
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.label === "÷2" ? "white" : "black";
            ctx.font = "bold 20px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.label, this.x, this.y);
            ctx.globalAlpha = 1.0;
            return remain > 0;
        }
    }

    function spawnLogic(now, elapsedSec) {
        const mult = spawnMult || 1;
        const spawnInterval = Math.max(250, (1000 - (elapsedSec * 15)) / mult);
        if (now - lastSpawnTime > spawnInterval) {
            const duration = Math.max(500, 2000 - (elapsedSec * 25));
            balloons.push(new Balloon(duration));
            lastSpawnTime = now;
        }
    }

    function getWeekKey() {
        const now = new Date();
        const firstDay = new Date(now.getFullYear(), 0, 1);
        const day = Math.floor((now - firstDay) / 86400000);
        const week = Math.floor((day + firstDay.getDay()) / 7);
        return `${now.getFullYear()}-W${week}`;
    }

    async function submitScore(name, score) {
        try {
            const weekKey = getWeekKey();
            const uid = user?.uid || null;

            const iconUrl = uid ? (profile?.iconUrl ?? null) : null;
            const nameColor = uid ? (profile?.equippedNameColor || profile?.nameColor || "black") : "black";

            await addDoc(collection(db, "scores"), {
                name,
                score,
                time: Date.now(),
                week: weekKey,
                uid,
                iconUrl,
                nameColor,
            });
        } catch (e) {
            console.error(e);
        }
    }

    async function loadRanking() {
        const weekKey = getWeekKey();
        const q = query(
            collection(db, "scores"),
            where("week", "==", weekKey),
            orderBy("score", "desc"),
            orderBy("time", "asc"),
            limit(10)
        );
        const snap = await getDocs(q);
        let arr = [];
        snap.forEach(d => arr.push({ id: d.id, ref: d.ref, ...d.data() }));
        return arr;
    }


    function refreshRanking() {
        rankingLoading = true;

        Promise.all([loadRanking(), refreshMyBestThisWeek(), refreshMyDocsThisWeek()])
          .then(([list]) => {
              rankingCache = list;
              rankingLoading = false;
          })
          .catch(() => {
              rankingCache = [];
              rankingLoading = false;
          });
    }

    async function updateMyWeekScoreName(newName) {
        if (!user?.uid) return;
        const weekKey = getWeekKey();

        const qOld = query(
            collection(db, "scores"),
            where("uid", "==", user.uid),
            limit(50)
        );
        const snap = await getDocs(qOld);
        for (const d of snap.docs) {
            const data = d.data();
            if (data.week === weekKey) {
                await updateDoc(d.ref, { name: newName });
            }
        }
    }

    async function updateMyWeekScoreCosmetics({ iconUrl, nameColor }) {
        if (!user?.uid) return;
        const weekKey = getWeekKey();

        const qOld = query(
            collection(db, "scores"),
            where("uid", "==", user.uid),
            limit(50)
        );
        const snap = await getDocs(qOld);

        for (const d of snap.docs) {
            const data = d.data();
            if (data.week === weekKey) {
                const patch = {};
                if (typeof iconUrl === "string") patch.iconUrl = iconUrl;
                if (typeof nameColor === "string") patch.nameColor = nameColor;
                if (Object.keys(patch).length) await updateDoc(d.ref, patch);
            }
        }
    }

    async function refreshMyBestThisWeek() {
        myBestThisWeek = -Infinity;
        if (!user?.uid) return;

        const weekKey = getWeekKey();
        const qMine = query(
            collection(db, "scores"),
            where("uid", "==", user.uid),
            limit(50)
        );
        const snap = await getDocs(qMine);
        for (const d of snap.docs) {
            const data = d.data();
            if (data.week === weekKey) {
                const s = Number(data.score);
                if (Number.isFinite(s)) myBestThisWeek = Math.max(myBestThisWeek, s);
            }
        }
    }
    async function refreshMyDocsThisWeek() {
        myScoreDocsThisWeek = [];
        if (!user?.uid) return;

        const weekKey = getWeekKey();
        const qMine = query(
            collection(db, "scores"),
            where("uid", "==", user.uid),
            limit(50)
        );
        const snap = await getDocs(qMine);
        for (const d of snap.docs) {
            const data = d.data();
            if (data.week === weekKey) {
                myScoreDocsThisWeek.push({ id: d.id, ref: d.ref, data });
            }
        }
    }
    const iconCache = new Map();
    function getIconImage(url) {
        if (!url) return null;
        if (iconCache.has(url)) return iconCache.get(url);
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.src = url;
        iconCache.set(url, img);
        return img;
    }

    function setRandomTip() {
        const t = tips[Math.floor(Math.random() * tips.length)];
        document.getElementById("tipText").textContent = "TIP: " + t;
    }

    async function googleLogin() {
        try {
            const result = await signInWithPopup(auth, provider);
            user = result.user;
        } catch (e) {
            console.error(e);
        }
    }

    async function googleLogout() {
        await signOut(auth);
        user = null;
    }

    function sanitizeName(raw) {
        if (!raw) return null;
        let name = String(raw).trim().slice(0, 10);
        if (!name) return null;
        if (!/^[ -~ㄱ-ㆎ가-힣ᄀ-ᇿힰ-ퟻꥠ-ꥼ]+$/.test(name)) return null;
        return name;
    }

    function userDocRef(uid) {
        return doc(db, "users", uid);
    }

    async function ensureUserProfile() {
        if (!user?.uid) {
            profile = null;
            return null;
        }

        const uid = user.uid;
        const ref = userDocRef(uid);
        const snap = await getDoc(ref);

        if (!snap.exists()) {
            const initialName =
                sanitizeName(user.displayName) ||
                "이름없음";

            const data = {
                name: initialName,
                coins: 0,
                iconUrl: GOOGLE_ICON_URL,
                updatedAt: Date.now(),

                nameColor: "black",
                ownedNameColors: ["black"],
                equippedNameColor: "black",
                ownedIcons: ["google"],
                equippedIcon: "google",
                ownedItems: [],
            };
            await setDoc(ref, data);
            profile = { uid, ...data };
            return profile;
        } else {
            const data = snap.data();
            profile = {
                uid,
                name: sanitizeName(data.name) || (sanitizeName(user.displayName) || "무명"),
                coins: Number.isFinite(data.coins) ? data.coins : 0,
                iconUrl: data.iconUrl || GOOGLE_ICON_URL,
                nameColor: data.nameColor || "black",
                ownedNameColors: Array.isArray(data.ownedNameColors) ? data.ownedNameColors : ["black"],
                equippedNameColor: data.equippedNameColor || (data.nameColor || "black"),
                ownedIcons: Array.isArray(data.ownedIcons) ? data.ownedIcons : ["google"],
                equippedIcon: data.equippedIcon || "google",
                ownedItems: Array.isArray(data.ownedItems) ? data.ownedItems : [],
            };
            const patch = {};
            if (!("nameColor" in data)) patch.nameColor = "black";
            if (!("ownedNameColors" in data)) patch.ownedNameColors = ["black"];
            if (!("equippedNameColor" in data)) patch.equippedNameColor = patch.nameColor || "black";
            if (!("ownedIcons" in data)) patch.ownedIcons = ["google"];
            if (!("equippedIcon" in data)) patch.equippedIcon = "google";
            if (!("ownedItems" in data)) patch.ownedItems = [];
            if (Object.keys(patch).length) await updateDoc(ref, patch);
            return profile;
        }
    }

    async function setProfileName(newName) {
        if (!user?.uid) return;
        const name = sanitizeName(newName);
        if (!name) throw new Error("bad_name");

        await updateDoc(userDocRef(user.uid), {
            name,
            updatedAt: Date.now(),
        });

        if (profile) profile.name = name;
        await updateMyWeekScoreName(name);
    }

    function getAutoName() {
        if (user && profile?.name) return profile.name;
        if (!user) return null;
        return sanitizeName(user.displayName);
    }

    async function creditCoinsOnce() {
        if (!user?.uid) return;
        if (coinsCredited) return;

        const gain = Math.max(0, score);
        coinsCredited = true;

        if (gain === 0) return;

        await updateDoc(userDocRef(user.uid), {
            coins: increment(gain),
            updatedAt: Date.now(),
        });

        if (profile) profile.coins += gain;
    }

    onAuthStateChanged(auth, async (u) => {
        user = u;

        if (user) {
            googleBtn.textContent = "로그아웃";
            googleBtn.classList.add("logout");

            try {
                await ensureUserProfile();
            } catch (e) {
                console.error(e);
                profile = null;
            }

            nameBtn.classList.remove("hidden");
            refreshRanking();
        } else {
            googleBtn.textContent = "구글 로그인";
            googleBtn.classList.remove("logout");
            nameBtn.classList.add("hidden");
            profile = null;

            myScoreDocsThisWeek = [];
            refreshRanking();
        }
    });

    function startTipCycle() {
        if (tipTimer) clearInterval(tipTimer);
        tipTimer = setInterval(() => {
            if (!isGameRunning && !isShowingResult) {
                setRandomTip();
            }
        }, 5000);
    }

    function startGame() {
        closeNameInput();
        startBtn.classList.add('hidden');
        downloadBtn.classList.add('hidden');
        gameTitle.classList.add('hidden');
        rankBtn.classList.add('hidden');
        googleBtn.classList.add('hidden');
        nameBtn.classList.add('hidden');
        shopBtn.classList.add('hidden');
        document.getElementById("tipText").style.display = "none";

        score = 0;
        balloons = [];
        floatingTexts = [];
        isGameRunning = false;
        isCountingDown = false;
        isStarting = true;
        isShowingResult = false;
        startCountdownValue = 3;
        hasSubmittedRank = false;
        coinsCredited = false;
        renderShop();
        gameDuration = BASE_GAME_DURATION;
        spawnMult = 1;
        if (usedItemThisRound && user && profile) {
            const it = SHOP.items.find(x => x.id === usedItemThisRound);
            if (it?.type === "time") {
                gameDuration += (it.addMs || 0);
            }
            if (it?.type === "spawn") {
                spawnMult = it.mult || 1;
            }
        }

        readySound.currentTime = 0;
        readySound.play();

        const startTimer = setInterval(() => {
            startCountdownValue--;
            if (startCountdownValue > 0) {
                readySound.currentTime = 0;
                readySound.play();
            } else {
                clearInterval(startTimer);
                isStarting = false;
                isGameRunning = true;
                startTime = Date.now();
                lastSpawnTime = 0;
                startSound.currentTime = 0;
                startSound.play();
                homeBtn.classList.remove('hidden'); 
            }
        }, 1000);
    }

    function goHome() {
        closeNameInput();
        startTime = 0;
        isGameRunning = false;
        isCountingDown = false;
        isStarting = false;
        isShowingResult = false;
        isShowingRanking = false;
        spawnMult = 1;
        usedItemThisRound = null;
        renderShop();

        startBtn.classList.remove('hidden');
        gameTitle.classList.remove('hidden');
        googleBtn.classList.remove('hidden');
        if (user) nameBtn.classList.remove('hidden');
        else nameBtn.classList.add('hidden');
        shopBtn.classList.remove('hidden');
        endButtons.classList.add('hidden');
        downloadBtn.classList.add('hidden');
        homeBtn.classList.add('hidden');
        rankBtn.classList.remove('hidden');
        document.getElementById("tipText").style.display = "block";
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        refreshRanking();
    }

    function handleGameOver() {
        isGameRunning = false;
        isCountingDown = true;
        homeBtn.classList.add('hidden');
        document.getElementById("tipText").style.display = "block";
        countdownValue = 3;

        const timer = setInterval(() => {
            countdownValue--;
            if (countdownValue <= 0) {
                clearInterval(timer);
                isCountingDown = false;

                endButtons.classList.remove('hidden');
                endButtons.style.marginTop = "180px";
                homeBtn.classList.remove('hidden');
                rankBtn.classList.remove('hidden');
                showResultBtn.classList.remove('hidden');
                googleBtn.classList.remove('hidden');
                shopBtn.classList.remove('hidden');
                if (user) nameBtn.classList.remove('hidden');
                else nameBtn.classList.add('hidden');
                spawnMult = 1;
                usedItemThisRound = null;
                renderShop();

                rankingLoading = true;
                loadRanking().then(list => {
                    rankingCache = list;
                    rankingLoading = false;
                });
            }
        }, 1000);
    }

    downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = `${userName}의 결과.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    });

    rankBtn.onclick = async () => {
        nameInputMode = null;
        document.getElementById("ui-overlay").classList.remove("only-input");
        nameInputBox.classList.add("hidden");
        nameInputBox.classList.remove("rank-mode");

        isShowingRanking = true;
        refreshRanking();
    };

    function update() {
        const now = Date.now();

        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (isShowingRanking) {
            const overlay = document.getElementById("ui-overlay");

            if (nameInputMode === "rank" || nameInputMode === "result") {
                overlay.style.display = "flex";
                overlay.classList.add("only-input", "rank-input");
            } else {
                overlay.style.display = "none";
                overlay.classList.remove("only-input", "rank-input");
            }

            ctx.fillStyle = "rgba(0,0,0,0.6)";
            ctx.fillRect(0,0,canvas.width,canvas.height);

            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.roundRect(140,80,520,440,16);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.font = "28px Arial";
            ctx.textAlign = "center";
            ctx.fillText("주간 순위", 400, 120);

            if (!rankingLoading && rankingCache) {
                ctx.font = "20px Arial";
                ctx.textBaseline = "middle";

                const baseX = 200;
                const iconSize = 24;

                for (let i = 0; i < rankingCache.length; i++) {
                    const r = rankingCache[i];
                    const y = 180 + i * 28;

                    ctx.textAlign = "left";
                    ctx.fillStyle = "black";
                    ctx.fillText(`${i + 1}. `, baseX - 30, y);

                    const iconUrl = r.iconUrl || GUEST_ICON_URL;
                    const img = getIconImage(iconUrl);
                    if (img?.complete) {
                        const drawHeight = iconSize * img.height / img.width;
                        ctx.drawImage(img, baseX, y - drawHeight / 2 - 2, iconSize, drawHeight);
                    }

                    const colorId = r.nameColor || "black";
                    const color = SHOP.nameColors.find(x => x.id === colorId)?.color || "black";

                    const nameX = baseX + iconSize + 6;

                    ctx.textAlign = "left";
                    ctx.fillStyle = color;
                    ctx.fillText(r.name, nameX, y);

                    ctx.textAlign = "right";
                    ctx.fillStyle = "black";
                    ctx.fillText(`${r.score}점`, 630, y);
                }

                ctx.textAlign = "center";
                ctx.textBaseline = "alphabetic";
            }

            const hasMine =
                !!user?.uid &&
                Array.isArray(myScoreDocsThisWeek) &&
                myScoreDocsThisWeek.length > 0;

            const canEnter =
                !!rankingCache &&
                startTime !== 0 &&
                !hasSubmittedRank &&
                (rankingCache.length < 10 || score > rankingCache[rankingCache.length - 1].score);

            submitRankBtn.classList.toggle("hidden", !canEnter || nameInputMode === "rank");

            requestAnimationFrame(update);
            return;
        }

        if (MAINT && !maintOk) {
            document.getElementById("ui-overlay").style.display = "none";

            if (maintImage.complete) {
                ctx.drawImage(maintImage, 0, 140, 800, 320);
            }

            requestAnimationFrame(update);
            return;
        }
        else {
            document.getElementById("ui-overlay").style.display = "flex";
        }

        if (isStarting) {
            ctx.fillStyle = "#ff4757";
            ctx.font = "bold 120px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(startCountdownValue, canvas.width / 2 - 20, canvas.height / 2);
            ctx.font = "bold 40px Arial";
            ctx.fillText("초", canvas.width / 2 + 40, canvas.height / 2 + 20);

            ctx.fillStyle = "black";
            ctx.font = "30px Arial";
            ctx.fillText(`0점 | ${gameDuration / 1000}초`, canvas.width / 2, 40);
        }
        else if (isGameRunning) {
            const elapsedTotal = now - startTime;
            const remTime = Math.max(0, (gameDuration - elapsedTotal) / 1000);
            if (remTime > 0) {
                spawnLogic(now, (gameDuration / 1000) - remTime);
            } else {
                handleGameOver();
            }
            balloons = balloons.filter(b => b.draw(now));
            floatingTexts = floatingTexts.filter(ft => {
                ft.draw();
                return ft.life > 0;
            });
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.font = "30px Arial";
            ctx.fillText(`${score}점 | ${Math.floor(remTime)}초`, canvas.width / 2, 40);
        } 
        else if (isShowingResult) {
            ctx.fillStyle = "black";
            ctx.font = "60px Arial";
            ctx.textAlign = "left";
            ctx.fillText(`${userName} 님의`, 60, canvas.height / 2 - 120);
            ctx.textAlign = "center";
            ctx.fillText(`풍선 터트리기 점수는`,canvas.width / 2, canvas.height / 2 - 30);
            ctx.textAlign = "right";
            ctx.fillText(`${score}점이에요!`, canvas.width - 60, canvas.height / 2 + 60);

            const qrSize = 100;
            const bottomY = canvas.height - 150;

            if (qrImage.complete) {
                ctx.drawImage(qrImage, canvas.width / 2 - qrSize / 2 - 210, bottomY, qrSize, qrSize);
            }

            ctx.fillStyle = "black";
            ctx.font = "50px Arial";
            ctx.textAlign = "left";
            ctx.fillText("풍선터트리기.kro.kr", canvas.width / 2 - 130, bottomY + qrSize/2 + 5);
        }
        else if (startTime !== 0) {
            ctx.fillStyle = "red";
            ctx.font = "60px Arial";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);

            ctx.fillStyle = "black";
            ctx.font = "30px Arial";
            ctx.fillText(`${score}점`, canvas.width / 2, canvas.height / 2 + 10);

            if (isCountingDown) {
                ctx.fillText(`${countdownValue}초...`, canvas.width / 2, canvas.height / 2 + 70);
            }
        }
        requestAnimationFrame(update);
    }

    canvas.addEventListener('mousedown', (e) => {
        if (!isGameRunning) return;
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        for (let i = balloons.length - 1; i >= 0; i--) {
            const b = balloons[i];
            const dist = Math.sqrt((b.x - mx)**2 + (b.y - my)**2);
            if (dist < b.radius) {
                popSound.currentTime = 0;
                popSound.play();
                const oldScore = score;
                const eff = b.conf.effect;
                if (eff === "double") score *= 2;
                else if (eff === "half") score = Math.floor(score / 2);
                else if (eff === "random") {
                    const rv = [1, 2, 3, -2][Math.floor(Math.random() * 4)];
                    score += rv;
                } else { score += eff; }
                const diff = score - oldScore;
                const diffText = diff >= 0 ? `+${diff}` : `${diff}`;
                const color = diff >= 0 ? "red" : "blue";
                floatingTexts.push(new FloatingText(b.x, b.y, diffText, color));
                balloons.splice(i, 1);
                break;
            }
        }
    });

    canvas.addEventListener("mousedown", ()=>{
        if (!shopModal.classList.contains("hidden")) return;

        if (nameInputMode === "rename") {
            closeNameInput();
            return;
        }

        if (isShowingRanking) {
            isShowingRanking = false;
            nameInputMode = null;
            document.getElementById("ui-overlay").classList.remove("only-input");
            nameInputBox.classList.add("hidden");
            submitRankBtn.classList.add("hidden");
            showResultBtn.classList.remove("hidden");
            document.getElementById("ui-overlay").style.display = "flex";
        }
        if (nameInputMode === "result") {
            nameInputBox.classList.add("hidden");
            showResultBtn.classList.remove("hidden");
            nameInputMode = null;
            return;
        }
    });

    homeBtn.addEventListener('click', () => {
        if (isShowingResult) {
            isShowingResult = false;
            downloadBtn.classList.add('hidden');
            endButtons.classList.remove('hidden');
            rankBtn.classList.remove('hidden');
            googleBtn.classList.remove("hidden");
            shopBtn.classList.remove('hidden');
            if (user) nameBtn.classList.remove('hidden');
            else nameBtn.classList.add('hidden');
            document.getElementById("tipText").style.display = "block";
            homeBtn.textContent = "처음으로";
            showResultBtn.classList.remove("hidden");
        } else {
            goHome();
        }
    });

    [startBtn, showResultBtn, submitRankBtn].forEach(btn => {
        btn.addEventListener('mouseenter', () => {
            popSound.currentTime = 0;
            popSound.play();
        });
    });

    [homeBtn, downloadBtn, rankBtn].forEach(btn => {
        btn.addEventListener('mouseenter', () => {
            tickSound.currentTime = 0;
            tickSound.play();
        });
    });

    nameInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            nameOkBtn.click();
        }
    });

    googleBtn.onclick = async () => {
        if (user) await googleLogout();
        else await googleLogin();
    };

    let shopTab = "name";

    function openShop() {
        closeNameInput();
        isShowingRanking = false;

        document.getElementById("ui-overlay").classList.add("only-shop");
        shopModal.classList.remove("hidden");

        updateShopCoins();
        renderShop();
    }

    function closeShop() {
        document.getElementById("ui-overlay").classList.remove("only-shop");
        shopModal.classList.add("hidden");
    }

    function updateShopCoins() {
        const coins = user && profile ? profile.coins : 0;
        shopCoinsEl.textContent = fmtCoins(coins);
    }

    function isOwned(list, id) {
        return Array.isArray(list) && list.includes(id);
    }

    async function spendCoins(amount) {
        if (!user?.uid || !profile) return false;
        if (profile.coins < amount) return false;

        profile.coins -= amount;
        await updateDoc(userDocRef(user.uid), {
            coins: increment(-amount),
            updatedAt: Date.now(),
        });
        updateShopCoins();
        return true;
    }

    async function buyNameColor(id) {
        const it = SHOP.nameColors.find(x => x.id === id);
        if (!it || !user?.uid) return;

        if (isOwned(profile.ownedNameColors, id)) return;

        const ok = await spendCoins(it.price);
        if (!ok) return;

        shopBuySound.currentTime = 0;
        shopBuySound.play();

        profile.ownedNameColors.push(id);
        await updateDoc(userDocRef(user.uid), {
            ownedNameColors: profile.ownedNameColors,
            updatedAt: Date.now(),
        });

        renderShop();
    }

    async function useNameColor(id) {
        if (!user?.uid || !profile) return;
        if (!isOwned(profile.ownedNameColors, id)) return;

        shopUseSound.currentTime = 0;
        shopUseSound.play();

        profile.equippedNameColor = id;
        profile.nameColor = id;
        await updateDoc(userDocRef(user.uid), {
            equippedNameColor: id,
            nameColor: id,
            updatedAt: Date.now(),
        });
        await updateMyWeekScoreCosmetics({ nameColor: id });

        renderShop();
        refreshRanking();
    }

    async function buyIcon(id) {
        const it = SHOP.icons.find(x => x.id === id);
        if (!it || !user?.uid) return;

        if (isOwned(profile.ownedIcons, id)) return;

        const ok = await spendCoins(it.price);
        if (!ok) return;

        shopBuySound.currentTime = 0;
        shopBuySound.play();

        profile.ownedIcons.push(id);
        await updateDoc(userDocRef(user.uid), {
            ownedIcons: profile.ownedIcons,
            updatedAt: Date.now(),
        });

        renderShop();
    }

    async function useIcon(id) {
        const it = SHOP.icons.find(x => x.id === id);
        if (!it || !user?.uid || !profile) return;
        if (!isOwned(profile.ownedIcons, id)) return;

        shopUseSound.currentTime = 0;
        shopUseSound.play();

        profile.equippedIcon = id;
        profile.iconUrl = it.url;

        await updateDoc(userDocRef(user.uid), {
            equippedIcon: id,
            iconUrl: it.url,
            updatedAt: Date.now(),
        });
        await updateMyWeekScoreCosmetics({ iconUrl: it.url });

        renderShop();
        refreshRanking();
    }

    async function buyItem(id) {
        const it = SHOP.items.find(x => x.id === id);
        if (!it || !user?.uid || !profile) return;
        if (isOwned(profile.ownedItems, id)) return;

        const ok = await spendCoins(it.price);
        if (!ok) return;

        shopBuySound.currentTime = 0;
        shopBuySound.play();

        profile.ownedItems.push(id);
        renderShop();

        await updateDoc(userDocRef(user.uid), {
            ownedItems: profile.ownedItems,
            updatedAt: Date.now(),
        });
    }

    function renderShop() {
        updateShopCoins();

        if (!user || !profile) {
            shopContent.innerHTML = `<div style="padding:16px;font-size:20px;">로그인해야 상점이 생겨요.</div>`;
            return;
        }

        if (shopTab === "name") {
            shopContent.innerHTML = SHOP.nameColors.map(it => {
                const owned = isOwned(profile.ownedNameColors, it.id);
                const using = (profile.equippedNameColor || "black") === it.id;

                const priceText = it.price === 0 ? "무료" : `${fmtCoins(it.price)} ⓒ`;

                return `
                    <div class="shop-row">
                        <div class="left">
                            <span style="color:${it.color}">${it.label}</span>
                            <span class="shop-badge">${priceText}</span>
                        </div>
                        <div class="shop-actions">
                            ${!owned ? `<button class="shop-mini buy" ${profile.coins < it.price ? "disabled" : ""} data-buy-name="${it.id}">구매</button>` : ""}
                            ${owned ? `<button class="shop-mini ${using ? "using" : "use"}" data-use-name="${it.id}">${using ? "사용 중" : "사용"}</button>` : ""}
                        </div>
                    </div>
                `;
            }).join("");
        }

        if (shopTab === "icon") {
            shopContent.innerHTML = SHOP.icons.map(it => {
                const owned = isOwned(profile.ownedIcons, it.id);
                const using = (profile.equippedIcon || "google") === it.id;

                const priceText = it.price === 0 ? "무료" : `${fmtCoins(it.price)} ⓒ`;

                return `
                    <div class="shop-row">
                        <div class="left">
                            <img src="${it.url}" style="width:26px;height:26px;object-fit:contain" crossorigin="anonymous"/>
                            <span>${it.label}</span>
                            <span class="shop-badge">${priceText}</span>
                        </div>
                        <div class="shop-actions">
                            ${!owned && it.id !== "developer" ? `<button class="shop-mini buy" ${profile.coins < it.price ? "disabled" : ""} data-buy-icon="${it.id}">구매</button>` : ""}
                            ${owned ? `<button class="shop-mini ${using ? "using" : "use"}" data-use-icon="${it.id}">${using ? "사용 중" : "사용"}</button>` : ""}
                        </div>
                    </div>
                `;
            }).join("");
        }

        if (shopTab === "item") {
            shopContent.innerHTML = SHOP.items.map(it => {
                const owned = isOwned(profile.ownedItems, it.id);
                const priceText = `${fmtCoins(it.price)} ⓒ`;
                const usingNow = (usedItemThisRound === it.id);

                return `
                    <div class="shop-row">
                        <div class="left">
                            <span>${it.label}</span>
                            <span class="shop-badge">${priceText}</span>
                        </div>
                        <div class="shop-actions">
                            ${!owned ? `<button class="shop-mini buy" ${profile.coins < it.price ? "disabled" : ""} data-buy-item="${it.id}">구매</button>`
                            : `<button class="shop-mini ${usingNow ? "using" : "use"}" data-use-item="${it.id}">${usingNow ? "사용 중" : "사용"}</button>`}
                        </div>
                    </div>
                `;
            }).join("");
        }
    }

    document.querySelectorAll(".shop-tab").forEach(btn => {
        btn.addEventListener("click", () => {
            shopTabSound.currentTime = 0;
            shopTabSound.play();
            document.querySelectorAll(".shop-tab").forEach(b => b.classList.remove("active"));
            btn.classList.add("active");
            shopTab = btn.dataset.tab;
            renderShop();
        });
    });

    shopContent.addEventListener("click", async (e) => {
        const t = e.target;
        if (!(t instanceof HTMLElement)) return;

        if (t.dataset.buyName) await buyNameColor(t.dataset.buyName);
        if (t.dataset.useName) await useNameColor(t.dataset.useName);

        if (t.dataset.buyIcon) await buyIcon(t.dataset.buyIcon);
        if (t.dataset.useIcon) await useIcon(t.dataset.useIcon);

        if (t.dataset.buyItem) await buyItem(t.dataset.buyItem);
        if (t.dataset.useItem) await useTempItem(t.dataset.useItem);
    });

    async function useTempItem(id) {
        if (!user?.uid || !profile) return;
        if (!isOwned(profile.ownedItems, id)) return;
        if (isGameRunning || isStarting || isCountingDown) return;

        shopUseSound.currentTime = 0;
        shopUseSound.play();

        if (usedItemThisRound === id) {
            usedItemThisRound = null;
            spawnMult = 1;
            gameDuration = BASE_GAME_DURATION;
            renderShop();
            return;
        }

        const it = SHOP.items.find(x => x.id === id);
        if (!it) return;

        usedItemThisRound = id;
        if (it.type === "spawn") {
            spawnMult = it.mult;
        }
        renderShop();
    }

    function closeNameInput() {
        nameInputBox.classList.add("hidden");
        nameInputBox.classList.remove("rank-mode", "rename-mode");
        nameError.textContent = "";
        nameInputMode = null;
        document.getElementById("ui-overlay").classList.remove("only-input", "rank-input");
    }

    nameBtn.onclick = () => {
        if (!user) return;

        nameInputMode = "rename";
        nameError.textContent = "";
        nameInput.value = profile?.name || getAutoName() || "";
        nameInputBox.classList.remove("rank-mode");
        nameInputBox.classList.remove("hidden");
        document.getElementById("nameInputLabel").textContent = "이름:";

        const overlay = document.getElementById("ui-overlay");

        nameInputBox.classList.add("rename-mode");
        nameInputBox.classList.remove("rank-mode");
    };

    submitRankBtn.onclick = async () => {
        if (hasSubmittedRank) return;
        const list = rankingCache;
        const canEnter =
            list.length < 10 ||
            score > list[list.length-1].score;
        if (!canEnter) return;

        const auto = getAutoName();
        if (auto) {
            userName = auto;
            await creditCoinsOnce();
            await submitScore(auto, score);
            hasSubmittedRank = true;
            isShowingRanking = true;
            refreshRanking();
            return;
        }

        nameInputMode = "rank";
        nameInput.value = "";
        nameError.textContent = "";
        submitRankBtn.classList.add("hidden");
        document.getElementById("nameInputLabel").textContent = "이름:";

        const overlay = document.getElementById("ui-overlay");
        overlay.classList.add("only-input", "rank-input");

        nameInputBox.classList.remove("rename-mode");

        nameInputBox.classList.add("rank-mode");
        nameInputBox.classList.remove("hidden");
    };

    showResultBtn.onclick = async () => {
        const auto = getAutoName();
        if (auto) {
            userName = auto;
            await creditCoinsOnce();
            isShowingResult = true;
            endButtons.classList.add("hidden");
            downloadBtn.classList.remove("hidden");
            rankBtn.classList.add("hidden");
            googleBtn.classList.add("hidden");
            shopBtn.classList.add('hidden');
            nameBtn.classList.add('hidden');
            homeBtn.textContent = "앞으로";
            document.getElementById("tipText").style.display = "none";
            nameInputMode = null;
            return;
        }

        nameInputMode = "result";
        nameInput.value = "";
        nameError.textContent = "";
        nameInputBox.classList.remove("rank-mode");
        nameInputBox.classList.remove("hidden");
        showResultBtn.classList.add("hidden");
        document.getElementById("nameInputLabel").textContent = "이름:";
    };

    nameOkBtn.onclick = async () => {
        const name = nameInput.value;

        if (!name) {
            return;
        }
        if (!/^[ -~ㄱ-ㆎ가-힣ᄀ-ᇿힰ-ퟻꥠ-ꥼ]+$/.test(name)) {
            nameError.textContent = "못 쓰는 문자가 있어요";
            return;
        }
        if (BAD.test(name)) {
            nameError.textContent = "나쁜 말은 못 써요";
            return;
        }

        if (nameInputMode === "rename") {
            if (!user) {
                nameError.textContent = "로그인해야 해요";
                return;
            }
            try {
                await setProfileName(name);
            } catch (e) {
                nameError.textContent = "이름 저장에 실패했어요";
                return;
            }

            nameInputBox.classList.add("hidden");
            nameInputBox.classList.remove("rename-mode");
            document.getElementById("ui-overlay").classList.remove("only-input");
            nameInputMode = null;
            return;
        }

        userName = name;
        nameInputBox.classList.add("hidden");
        nameInputBox.classList.remove("rank-mode");
        document.getElementById("ui-overlay").classList.remove("only-input");

        if (nameInputMode === "result") {
            isShowingResult = true;
            endButtons.classList.add("hidden");
            downloadBtn.classList.remove("hidden");
            rankBtn.classList.add("hidden");
            shopBtn.classList.add("hidden");
            homeBtn.textContent = "앞으로";
            document.getElementById("tipText").style.display = "none";
        }

        if (nameInputMode === "rank") {
            await submitScore(name, score);
            hasSubmittedRank = true;
            isShowingRanking = true;
            refreshRanking();
        }

        nameInputBox.classList.remove("rename-mode");
        nameInputMode = null;
    };

    shopBtn.onclick = () => {
        openShop();
    };
    shopCloseBtn.onclick = () => {
        closeShop();
    };

    const adModal = document.getElementById('adModal');
    const closeAdBtn = document.getElementById('closeAdBtn');

    function showAdAndStart() {
        if (!document.querySelector('.kakao_ad_area iframe')) {
            startGame();
            return;
        }

        adModal.classList.add('show');

        let remain = 3;
        closeAdBtn.disabled = true;
        closeAdBtn.textContent = remain;

        const adTimer = setInterval(() => {
            remain--;
            if (remain > 0) {
                closeAdBtn.textContent = remain;
            } else {
                clearInterval(adTimer);
                closeAdBtn.disabled = false;
                closeAdBtn.textContent = '✕';
            }
        }, 1000);

        closeAdBtn.onclick = () => {
            if (closeAdBtn.disabled) return;
            adModal.classList.remove('show');
            startGame();
        };
    }
    startBtn.onclick = showAdAndStart;

    window.addEventListener("keydown", (e) => {
        if (!MAINT || maintOk) return;

        maintSeq += e.key.toLowerCase();

        if (!"asdf".startsWith(maintSeq)) {
            maintSeq = "";
            return;
        }

        if (maintSeq === "asdf") {
            maintOk = true;
            maintSeq = "";
            refreshRanking();
        }
    });

    refreshRanking();
    endButtons.style.marginTop = "0px";
    rankBtn.classList.remove('hidden');
    setRandomTip();
    startTipCycle();
    update();
</script>
</body>
</html>
